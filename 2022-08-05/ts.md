# Зачем Typescript?

Typescript - это надстройка над Javascript для возможности проверки типов параметров, переменных, полей в объектах, и т.д.
В большинстве случаев, если убрать из кода Typescript все упоминания типов, то получается код Javascript.
Например, код на Javascript:

```js
const f = (a1, a2) => { console.log(a1 + a2); };
```

Функция `f` принимает параметры `a1` и `a2`, внутри функции идет их использование с помощью операции `+`.
Если хотя бы один из параметров будет строкой - будет "конкатенация" (сцепление) строк.
Если оба параметра являются числами, будет их сложение.

При использовании Typescript код будет более понятным:

```ts
const f1 = (a1: string, a2: number) => { console.log(a1 + a2); };
const f2 = (a1: number, a2: number) => { console.log(a1 + a2); };
```

Во-первых, в обоих функциях `f1` и `f2` видно, параметры каких типов ожидает каждая функция.
Во-вторых, из-за указания типов видно, что в `f1` предполагается "конкатенация" строк, а в `f2` - сложение чисел.


# Как создавать и использовать типы

## Примитивы

Пример указания типа:

```ts
const str: string;
let num: number;
const bool = true;
```

* `str` - строка
* `num` - число
* `bool` - логическое значение

С `bool` прикол в том, что компилятор определяет тип на основе присвоенного значения.
В данном случае это будет `boolean`.

## Типы объектов

Для создания типа объекта без использования классов можно использовать интерфейсы:

```ts
interface Data {
    n: number;
    s: string;
}
```

После этого можно создать какой-нибудь объект, который реализует этот интерфейс:

```ts
const original: Data = {
    n: 1,
    s: 'S',
};
```

ℹ️ При создании объекта таким образом IDE может предлагать варианты имен полей на основе интерфейса, а также скорее всего будет материться на пропущенные поля.

Созданный интерфейс можно использовать и в других случаях, например:

```ts
const arr: Array<Data> = [ ... ];
arr.forEach((item) => {
    ...
});
```

В этом примере `arr` - это массив элементов, каждый из которых реализует интерфейс `Data`.
Из-за этого IDE позволит работать с `item` как с объектом `Data` и сможет подсказывать поля, которые относятся к этому объекту.

ℹ️ Типы объектов можно описывать и через `type`:

```ts
type Data = {
    n: number;
    s: string;
}
```

Вроде бы никаких отличий нет, кроме того, что это выглядит не как описание типа, а как присвоение.

## Типы функций

Для функций можно тоже создавать типы:

```ts
type Fun = (delay: number, alias: string, nextDate: Date) => number;
```

Тут создается тип функции `Fun`.
Функции такого типа могут принимать параметры `delay`, `alias`, `nextDate` и должны возвращать число как результат своего выполнения.

Создание функции, соответствующей этому типу:

```ts
const f: Fun = (delay, a2) => { ... };
```

Паниковать не надо, функция `f` соответствует типу `Fun`:

* параметр `delay` функции соответствует параметру `delay` в типе и является числом
* параметр `a2` функции соответствует параметру `alias` в типе и является строкой
* параметр `nextDate` в фунции не используется, поэтому в функции не описан (но при вызове `f` его все равно надо передавать)

## "type" или "interface"?

Для описания типов объектов обычно используется `interface`, а для функций, совмещенных типов и т.п. - `type`.

## Generics (обобщения)

Используется для указания "тут может быть ~~ваша реклама~~ что угодно".
Например, тип массива в стандартных типах описывается так:

```ts
interface Array<T> {
    ...
    push(...items: T[]): number;
    ...
}
```

Здесь `T` - это тип-обобщение.
А метод `push` написан так, что может принимать только элементы типа `T`.

Из-за этого при использовании такого массива:

```ts
const a: Array<string> = [];
```

в вызов `a.push(...)` можно передавать только строки - `T` из описания типа подменяется на `string` из описания переменной.

Обобщения используются в типе `Set`:

```ts
const set = new Set<string>();
set.forEach((item) => {}); // item - строка
```

И в типе `Map`:

```ts
const map = new Map<string, Data>();

const res = map.get(''); // res - объект типа Data

map.forEach((value, key, source) => {
    // value - объект типа Data
    // key - строка
    // source - это map
});
```

Обобщения можно использовать в своих типах:

```ts
interface Data<T> { value: T; }

const a: Data<string> = { value: '' };
```

И в функциях:

```ts
interface Data<T> { value: T; }

const processResponse1 = <T>(data: Data<T>): T => { return data.value; };

const processResponse2 = (data: Data<string>): string => { return data.value; };
```

### Уточнение обобщения

Есть возможность ограничивать типы, которые могут быть подставлены вместо типа-обобщения:

```ts
interface Data<T> { value: T; }

const processResponse = <T extends string | number>(data: Data<T>): T => { return data.value; };

const result = processResponse<number>({ value: 123 });
```

В описании функции `processResponse` указано, что вместо `T` можно использовать строки или числа.

При вызове функции `processResponse` указано, что вместо `T` используются числа.
Т.е. `processResponse<number>({ value: true })` приведет к ошибке компиляции.

## Уточнение массивов

При использовании массивов можно указать их точный размер и тип каждого элемента в массива:

```ts
type MyArr = [string, Date, number];
```

Описание означает, что тип `MyArr` - массив из трех элементов: строка, дата и число.

## Совмещение типов

Еще одна развеселая штука в Typescript - совмещение типов:

```ts
interface ErrorData { message: string; }

interface SuccessData { id: number; }

type Data = ErrorData | SuccessData;

const data: Data = ... ;
```

Если кратко, то `Data` - это `ErrorData` или `SuccessData`.
Т.е. в объекте `data` может быть свойство `message` или свойство `id`.

Работать, правда, с таким описанием совсем неудобно, лучше его расширить:

```ts
interface ErrorData {
    type: 'error';
    message: string;
}

interface SuccessData {
    type: 'success';
    id: number;
}

type Data = ErrorData | SuccessData;
```

Получается, что в объекте типа `Data` в любом случае есть поле `type`, которое может иметь только одно из значений:

* `error` - значит объект типа `ErrorData`
* `success` - значит объект типа `SuccessData`

С таким описанием компилятор уже умеет нормально работать, следующий код не вызывает ошибок:

```ts
const processData = (data: Data) => {
    if (data.type === 'error') {
        console.error('Error:', data.message);
    } else {
        console.log('ID:', data.id);
    }
};
```

Вне блоков `if` и `else` тип объекта `data` для компилятора еще неопределен, зато компилятор понимает, что внутри условия `if (data.type === 'error')` этот объект может иметь только тип `ErrorData`, а внутри `else` - тип `SuccessData`.
